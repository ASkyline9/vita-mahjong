<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Relaxing Mahjong — Sleep Helper Game for Adults 30+</title>
  <meta name="description" content="Relaxing Mahjong-style puzzle designed for adults 30+. Large tiles, calm night theme, and gentle mechanics to help you unwind before bed. Play in browser — free." />
  <meta name="keywords" content="relaxing game, sleep game, mahjong solitaire, calming puzzle, stress relief game, games for adults, sleep helper" />
  <meta name="author" content="askyline9" />
  <meta property="og:title" content="Relaxing Mahjong — Sleep Helper Game for Adults 30+" />
  <meta property="og:description" content="Relaxing Mahjong-style puzzle designed for adults 30+. Large tiles and calm visuals to help you relax and sleep better." />
  <meta property="og:type" content="website" />
  <style>
    :root{
      --bg-1: #070621; /* deep navy */
      --bg-2: #0f1b3a; /* dark indigo */
      --panel: rgba(255,255,255,0.03);
      --muted: #9fb3c8;
      --accent: #c9b8ff; /* soft lavender */
      --tile-face: #e8f6ff;
      --tile-dark: #152b3a;
      --glass: rgba(255,255,255,0.02);
      --card-radius: 14px;
    }
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;background: radial-gradient(1200px 400px at 10% 10%, rgba(120,86,200,0.08), transparent 8%), linear-gradient(180deg,var(--bg-1), var(--bg-2)); color:var(--tile-face); -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale}
    .container{max-width:1100px;margin:20px auto;padding:18px; display:grid; grid-template-columns: 1fr 380px; gap:18px;}
    header{grid-column:1/-1; display:flex; align-items:center; justify-content:space-between; gap:12px}
    h1{margin:0;font-size:20px}
    .sub{color:var(--muted);font-size:13px}
    .game-area{background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008)); border-radius:var(--card-radius); padding:12px; display:flex; flex-direction:column; align-items:center; min-height:560px; box-shadow: 0 8px 40px rgba(2,6,23,0.7);}
    canvas{border-radius:10px; background: radial-gradient(circle at 30% 20%, rgba(255,255,255,0.02), transparent 10%), rgba(1,12,30,0.6); box-shadow: inset 0 2px 0 rgba(255,255,255,0.02), 0 12px 40px rgba(0,0,0,0.6);}
    .panel{background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:var(--card-radius); padding:14px; min-height:560px; display:flex; flex-direction:column; gap:12px; box-shadow: 0 8px 30px rgba(0,0,0,0.45);}
    .controls{display:flex; gap:8px; flex-wrap:wrap}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06); color:var(--tile-face); padding:10px 12px;border-radius:10px;font-size:14px; cursor:pointer}
    button.primary{background:linear-gradient(180deg, rgba(200,170,255,0.08), rgba(120,90,255,0.06)); border:1px solid rgba(200,170,255,0.12); box-shadow: 0 6px 18px rgba(0,0,0,0.6)}
    .muted{color:var(--muted);font-size:13px}
    .tile-count{font-weight:700; font-size:14px}
    .infoBox{background:var(--glass); padding:10px; border-radius:8px; color:var(--muted)}
    .center{text-align:center}
    .footer{grid-column:1/-1; color:var(--muted); font-size:13px; margin-top:10px}
    .subscribe-row{display:flex; gap:8px; margin-top:8px}
    input[type="email"]{padding:10px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04); background:transparent;color:var(--tile-face); flex:1}
    @media (max-width:980px){
      .container{grid-template-columns:1fr; padding:12px}
      .panel{min-height:320px}
      .game-area{min-height:420px}
    }
    /* small visual flourish */
    .logo-small{display:inline-block; padding:6px 10px; border-radius:999px; background:linear-gradient(90deg,#8073ff,#aeb2ff); color:#041026; font-weight:700}
  </style>

  <!-- EmailJS library (same as used earlier) -->
  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@3.2.0/dist/email.min.js"></script>
</head>
<body>
  <div class="container" role="main">
    <header>
      <div>
        <div style="display:flex;align-items:center;gap:12px">
          <div class="logo-small">RelaxSleep</div>
          <div>
            <h1>Relaxing Mahjong — Sleep Helper</h1>
            <div class="sub">Large tiles • Calming night theme • For adults 30+</div>
          </div>
        </div>
      </div>
      <div style="text-align:right">
        <div class="muted">Dev: askyline9</div>
        <div class="muted">Share: Facebook · Reddit</div>
      </div>
    </header>

    <section class="game-area" aria-label="Game area">
      <canvas id="gameCanvas" width="820" height="540" aria-label="Relaxing mahjong game canvas"></canvas>

      <div style="margin-top:12px; display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap;">
        <button id="restartBtn" class="primary">Restart / Shuffle</button>
        <button id="hintBtn">Hint</button>
        <button id="undoBtn">Undo</button>
        <button id="toggleGridBtn">Toggle Grid</button>
      </div>

      <div style="margin-top:10px; color:var(--muted); font-size:13px; text-align:center; max-width:820px;">
        Tip: Tap/click two matching tiles that are <strong>free</strong> (have an open side) to remove them. Remove all tiles to win. This game is intentionally calm and unhurried — good for unwinding before bed.
      </div>
    </section>

    <aside class="panel" aria-label="Controls and info">
      <div class="infoBox">
        <div style="font-weight:700">About this game</div>
        <div class="muted" style="margin-top:6px">A calm Mahjong-style puzzle tailored for adults who want a low-stress play before sleep. Large tiles and gentle visuals help reduce eye strain and quiet the mind.</div>
      </div>

      <div>
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div class="muted">Tiles remaining</div>
          <div id="tilesRemaining" class="tile-count">—</div>
        </div>
        <div style="margin-top:10px; display:flex; gap:8px;">
          <!-- buttons in game area already provide controls; kept for ease -->
        </div>
      </div>

      <div class="infoBox">
        <div style="font-weight:700">Stay updated (optional)</div>
        <div class="muted" style="margin-top:6px">Enter your email to receive occasional updates about game improvements or new relaxing puzzles.</div>

        <div class="subscribe-row">
          <input type="email" id="subscribeEmail" placeholder="Your email (optional)" aria-label="Subscribe email">
          <button id="subscribeBtn">Subscribe</button>
        </div>
        <div id="subscribeStatus" class="muted" style="margin-top:8px"></div>
      </div>

      <div style="margin-top:auto;">
        <div class="muted">SEO snippet: Relaxing Mahjong — play to unwind before sleep. Large tiles & calm visuals. Free browser game.</div>
      </div>
    </aside>

    <div class="footer" style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
      <div>© 2025 <a href="https://askyline9.github.io/" target="_blank" style="color:var(--accent); text-decoration:none">Skyline Hub</a> — Relax & Sleep Game Hub</div>
      <div class="muted">Contact: <a href="mailto:aa.skyline99@gmail.com" style="color:var(--muted); text-decoration:none">aa.skyline99@gmail.com</a></div>
    </div>
  </div>

  <script>
  /* ===== Relaxing Mahjong - Plain JS - Play immediately on load =====
     - Grid board
     - Tile free rule: at least one side (left OR right) empty
     - Simple hint & undo
     - Responsive canvas
  */

  (function(){
    // CONFIG
    const ROWS = 6;
    const COLS = 12;
    const TILE_PAD = 8;
    const TILE_W_BASE = 64;
    const TILE_H = 86;

    // state
    let board = [];
    let faces = [];
    let selected = null;
    let lastRemoved = null;
    let showingHint = null;
    let drawGrid = false;

    // canvas
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // ui elements
    const restartBtn = document.getElementById('restartBtn');
    const hintBtn = document.getElementById('hintBtn');
    const undoBtn = document.getElementById('undoBtn');
    const tilesRemainingEl = document.getElementById('tilesRemaining');
    const toggleGridBtn = document.getElementById('toggleGridBtn');

    // utilities
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } }

    function computeTileSize(){
      const availableW = canvas.width - (COLS + 1) * TILE_PAD;
      const w = Math.min(TILE_W_BASE, Math.floor(availableW / COLS));
      return {w, h: TILE_H};
    }

    function initBoard(){
      board = Array.from({length:ROWS},()=>Array.from({length:COLS},()=>null));
      const fillPos = [];
      for(let r=0;r<ROWS;r++){
        for(let c=1;c<COLS-1;c++){
          if ((r===0 && (c<2 || c>COLS-3)) || (r===ROWS-1 && (c<2 || c>COLS-3))) continue;
          if (Math.random() < 0.08) continue;
          fillPos.push([r,c]);
        }
      }
      if (fillPos.length % 2 === 1) fillPos.pop();

      const SYMBOLS = ['🀄','🀇','🀈','🀉','🀊','🀋','🀌','🀍','🀎','🀏','🀐','🀑','🀒','🀓','🀔','🀕','🀖','🀗','🀘'];
      const pairCount = Math.floor(fillPos.length/2);
      faces = [];
      for(let i=0;i<pairCount;i++){
        const sym = SYMBOLS[i % SYMBOLS.length] || (''+(i%99));
        faces.push(sym,sym);
      }
      shuffle(faces);
      shuffle(fillPos);
      for(let i=0;i<faces.length;i++){
        const [r,c] = fillPos[i];
        board[r][c] = {face:faces[i], removed:false, flash:false};
      }
    }

    function tileIsFree(r,c){
      const tile = board[r] && board[r][c];
      if (!tile) return false;
      const left = (c-1>=0) && board[r][c-1];
      const right = (c+1<COLS) && board[r][c+1];
      return !left || !right;
    }

    function findHint(){
      for(let r1=0;r1<ROWS;r1++){
        for(let c1=0;c1<COLS;c1++){
          if (!board[r1][c1] || board[r1][c1].removed) continue;
          if (!tileIsFree(r1,c1)) continue;
          for(let r2=r1;r2<ROWS;r2++){
            for(let c2=0;c2<COLS;c2++){
              if (r1===r2 && c1===c2) continue;
              if (!board[r2][c2] || board[r2][c2].removed) continue;
              if (!tileIsFree(r2,c2)) continue;
              if (board[r1][c1].face === board[r2][c2].face) return {r1,c1,r2,c2};
            }
          }
        }
      }
      return null;
    }

    function updateRemaining(){
      let count=0;
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if (board[r][c] && !board[r][c].removed) count++;
      tilesRemainingEl.textContent = count;
    }

    // rendering
    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const {w:tileW, h:tileH} = computeTileSize();
      const totalW = COLS*tileW + (COLS+1)*TILE_PAD;
      const totalH = ROWS*tileH + (ROWS+1)*TILE_PAD;
      const startX = Math.max(12, (canvas.width - totalW)/2);
      const startY = Math.max(12, (canvas.height - totalH)/2);

      // subtle stars / gradient
      // (kept minimal for calmer rendering)

      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const tile = board[r][c];
          const x = startX + TILE_PAD + c*(tileW + TILE_PAD);
          const y = startY + TILE_PAD + r*(tileH + TILE_PAD);

          if (!tile){
            if (drawGrid){
              ctx.strokeStyle = 'rgba(255,255,255,0.02)';
              ctx.strokeRect(x,y,tileW,tileH);
            }
            continue;
          }
          if (tile.removed) continue;

          // outer card
          ctx.save();
          ctx.shadowColor = 'rgba(0,0,0,0.7)';
          ctx.shadowBlur = 12;
          ctx.shadowOffsetY = 6;
          roundedRect(ctx, x, y, tileW, tileH, 10, true, true, 'rgba(255,255,255,0.02)', 'rgba(255,255,255,0.03)');
          ctx.restore();

          // inner face area
          const inset = 8;
          roundedRect(ctx, x+inset, y+inset, tileW-inset*2, tileH-inset*2, 8, true, true, '#0f2b3f', 'rgba(255,255,255,0.02)');

          // face symbol
          ctx.fillStyle = '#f6fbff';
          ctx.font = `${Math.floor(tileH*0.42)}px serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(tile.face, x + tileW/2, y + tileH/2 + 2);

          // selection outline
          if (selected && selected.r===r && selected.c===c){
            ctx.strokeStyle = 'rgba(200,170,255,0.95)';
            ctx.lineWidth = 4;
            roundedRect(ctx, x+3, y+3, tileW-6, tileH-6, 8, false, true);
          }

          // hint highlight
          if (showingHint && ((showingHint.r1===r && showingHint.c1===c) || (showingHint.r2===r && showingHint.c2===c))){
            ctx.strokeStyle = 'rgba(180,220,255,0.9)';
            ctx.lineWidth = 3.5;
            roundedRect(ctx, x+4, y+4, tileW-8, tileH-8, 8, false, true);
          }

          // tiny flash if blocked clicked
          if (tile.flash){
            ctx.fillStyle = 'rgba(255,255,255,0.03)';
            roundedRect(ctx, x, y, tileW, tileH, 10, true, false);
          }
        }
      }
    }

    function roundedRect(ctx, x, y, w, h, r, fill=true, stroke=true, fillStyle='rgba(255,255,255,0.02)', strokeStyle='rgba(255,255,255,0.04)'){
      if (w < 2*r) r = w/2;
      if (h < 2*r) r = h/2;
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
      if (fill){ ctx.fillStyle = fillStyle; ctx.fill(); }
      if (stroke){ ctx.strokeStyle = strokeStyle; ctx.lineWidth = 1.2; ctx.stroke(); }
    }

    // interactions
    function coordsFromMouse(mx,my){
      const {w:tileW, h:tileH} = computeTileSize();
      const totalW = COLS*tileW + (COLS+1)*TILE_PAD;
      const startX = Math.max(12, (canvas.width - totalW)/2);
      const totalH = ROWS*tileH + (ROWS+1)*TILE_PAD;
      const startY = Math.max(12, (canvas.height - totalH)/2);
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const x = startX + TILE_PAD + c*(tileW + TILE_PAD);
          const y = startY + TILE_PAD + r*(tileH + TILE_PAD);
          if (mx >= x && mx <= x+tileW && my >= y && my <= y+tileH) return {r,c,x,y,tileW,tileH};
        }
      }
      return null;
    }

    function onCanvasClick(e){
      const rect = canvas.getBoundingClientRect();
      const clientX = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX);
      const clientY = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY);
      const mx = clientX - rect.left;
      const my = clientY - rect.top;
      const pos = coordsFromMouse(mx,my);
      if (!pos) return;
      const {r,c} = pos;
      const tile = board[r][c];
      if (!tile || tile.removed) return;
      if (!tileIsFree(r,c)){ tile.flash = true; setTimeout(()=>{ tile.flash=false; draw(); }, 240); draw(); return; }
      if (!selected){ selected = {r,c}; showingHint = null; draw(); return; }
      if (selected.r === r && selected.c === c){ selected = null; draw(); return; }
      const selTile = board[selected.r][selected.c];
      if (selTile && selTile.face === tile.face && tileIsFree(selected.r,selected.c) && tileIsFree(r,c)){
        // remove
        board[selected.r][selected.c].removed = true;
        board[r][c].removed = true;
        lastRemoved = {r1:selected.r,c1:selected.c,r2:r,c2:c,face:selTile.face};
        selected = null;
        updateRemaining();
        draw();
        checkWin();
        return;
      } else {
        selected = {r,c};
        draw();
      }
    }

    canvas.addEventListener('click', onCanvasClick);
    canvas.addEventListener('touchstart', function(e){ e.preventDefault(); onCanvasClick(e); }, {passive:false});

    restartBtn.addEventListener('click', ()=> startGame());
    hintBtn.addEventListener('click', ()=>{
      const h = findHint();
      showingHint = h;
      draw();
      if (!h) alert('No available matching free pairs found.');
    });
    undoBtn.addEventListener('click', ()=> { if (!lastRemoved) { alert('Nothing to undo'); return; } const {r1,c1,r2,c2,face}=lastRemoved; board[r1][c1]={face,removed:false}; board[r2][c2]={face,removed:false}; lastRemoved=null; updateRemaining(); draw(); });

    toggleGridBtn.addEventListener('click', ()=> { drawGrid = !drawGrid; draw(); });

    // responsive canvas sizing
    function resizeCanvas(){
      const parent = canvas.parentElement;
      const maxW = Math.min(920, parent.clientWidth - 4);
      canvas.width = Math.max(560, Math.min(920, maxW));
      canvas.height = Math.max(420, Math.min(680, Math.floor(window.innerHeight*0.56)));
      draw();
    }
    window.addEventListener('resize', resizeCanvas);

    function checkWin(){
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if (board[r][c] && !board[r][c].removed) return;
      setTimeout(()=> {
        draw();
        const again = confirm("You cleared the board — well done! Play again?");
        if (again) startGame();
      }, 220);
    }

    // start / update
    function startGame(){
      initBoard();
      selected = null;
      lastRemoved = null;
      showingHint = null;
      updateRemaining();
      resizeCanvas();
      draw();
    }

    // initial start immediately
    startGame();

    // expose for debugging if needed
    window._relaxMahjong = { board, startGame, findHint };

  })();
  </script>

  <!-- Email notification logic (sends an email when page loads; also handles subscribe) -->
  <script>
  (function(){
    // EmailJS public key & service/template ids from your earlier file
    const EMAILJS_PUBLIC_KEY = 'u8q8lvRWe9DBYUXRt';
    const EMAILJS_SERVICE = 'service_cc9cmen';
    const EMAILJS_TEMPLATE = 'template_kel4u0e'; // existing template used earlier

    // init emailjs if library loaded
    function initEmailJS(){
      if (typeof emailjs === 'undefined') {
        console.warn('EmailJS library not loaded — visit notifications will not be sent.');
        return false;
      }
      try {
        emailjs.init(EMAILJS_PUBLIC_KEY);
        return true;
      } catch(e){
        console.warn('EmailJS init error', e);
        return false;
      }
    }

    // get visitor IP
    async function getVisitorIP(){
      try {
        const resp = await fetch('https://api.ipify.org?format=json');
        const data = await resp.json();
        return data.ip || 'Unknown';
      } catch(e){
        return 'Unavailable';
      }
    }

    // detect likely bot
    function likelyBot(userAgent){
      return /bot|crawl|spider|slurp|teoma|archive|track|screenshot|monitoring|fetch|java|curl|wget|python|php|ruby|perl|go|node|libwww/i.test(userAgent);
    }

    async function sendVisitNotification(){
      if (!initEmailJS()) return;
      const ip = await getVisitorIP();
      const page = window.location.href;
      const referrer = document.referrer || 'Direct';
      const time = new Date().toLocaleString('en-MY', { hour12: true });
      const userAgent = navigator.userAgent;
      const screenResolution = `${window.screen.width}x${window.screen.height}`;
      const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'Unknown';
      const isBot = likelyBot(userAgent);

      const message = `
New visitor to Relaxing Mahjong
Page: ${document.title}
URL: ${page}
Time: ${time}
Timezone: ${timezone}
Referrer: ${referrer}
IP: ${ip}
Screen: ${screenResolution}
User Agent: ${userAgent}
Detected: ${isBot ? 'Likely Bot' : 'Likely Human'}
      `;

      const templateParams = {
        to_email: 'aa.skyline99@gmail.com',
        from_name: 'Relaxing Mahjong Visitor',
        message: message,
        reply_to: 'noreply@skylinehub.com',
        subject: 'New Visitor Relaxing Mahjong'
      };

      try{
        emailjs.send(EMAILJS_SERVICE, EMAILJS_TEMPLATE, templateParams)
          .then(function(response) {
            console.log('Visit notification sent', response.status, response.text);
          }, function(error) {
            console.log('Failed to send visit notification', error);
          });
      }catch(e){
        console.warn('Email send error', e);
      }
    }

    // Subscribe button: sends an email with the subscriber email address
    const subscribeBtn = document.getElementById('subscribeBtn');
    const subscribeEmailInput = document.getElementById('subscribeEmail');
    const subscribeStatus = document.getElementById('subscribeStatus');

    subscribeBtn && subscribeBtn.addEventListener('click', async function(){
      const email = (subscribeEmailInput && subscribeEmailInput.value || '').trim();
      if (!email || !/^\S+@\S+\.\S+$/.test(email)){
        subscribeStatus.textContent = 'Please enter a valid email address.';
        return;
      }
      if (!initEmailJS()){
        subscribeStatus.textContent = 'Subscription temporarily unavailable.';
        return;
      }
      subscribeStatus.textContent = 'Sending…';
      const ip = await getVisitorIP();
      const templateParams = {
        to_email: 'aa.skyline99@gmail.com',
        from_name: 'Relaxing Mahjong Subscribe',
        message: `New subscriber: ${email}\nFrom page: ${location.href}\nIP: ${ip}`,
        reply_to: email,
        subject: 'Relaxing Mahjong - New Subscriber'
      };
      emailjs.send(EMAILJS_SERVICE, EMAILJS_TEMPLATE, templateParams)
        .then(function(resp){
          subscribeStatus.textContent = 'Thanks — you are subscribed (we will email updates occasionally).';
          subscribeEmailInput.value = '';
        }, function(err){
          console.error('Subscription send error', err);
          subscribeStatus.textContent = 'Failed to subscribe. Try again later.';
        });
    });

    // Run visit notification on page load (immediately)
    window.addEventListener('DOMContentLoaded', function(){
      // small delay to avoid blocking UI
      setTimeout(()=>{ sendVisitNotification(); }, 700);
    });
  })();
  </script>
</body>
</html>
